# Планирование (`start`, `duration`, `after`, `excludes`)

Поля планирования позволяют задать временные характеристики узлов и зависимости между ними.

## Термины

- **Календарь представления (calendar(view))** — функция, определяющая, какие дни считаются рабочими для данного представления. Зависит от параметра `excludes` в представлении.
- **Рабочий день (workday)** — день, который НЕ исключён календарём представления. При `excludes: ["weekends"]` рабочими являются пн–пт. При пустом `excludes` рабочим является любой календарный день.
- **Core excludes** — значения в `excludes`, которые влияют на расчёт дат: `"weekends"` и даты в формате `YYYY-MM-DD`.
- **Non-core excludes** — прочие значения в `excludes` (не стандартизованы); переносимые инструменты ДОЛЖНЫ игнорировать их с предупреждением.
- **Планируемый узел (scheduled)** — узел, для которого можно вычислить дату начала (`start`). Такие узлы отображаются на временной шкале.
- **Непланируемый узел (unscheduled)** — узел без явного `start`, без `finish` и без вычислимого `start` через `after`. Такие узлы НЕ отображаются на временной шкале.
- **Эффективный start (effective_start)** — нормализованная дата начала, используемая в вычислениях. Если `start` узла попадает на исключённый день (и узел не является вехой), эффективный start сдвигается на следующий рабочий день.

> **Важно:** расписание вычисляется для каждого представления отдельно. План хранит ограничения (constraints), представления применяют правила календаря. Один и тот же узел может иметь разные вычисленные даты в разных представлениях с разными `excludes`.

## Поля планирования

### `start` *(string, YYYY-MM-DD)*

Плановая дата начала работы. Формат: ISO 8601 дата, например `2024-03-15`.

- Если указан `start`, узел считается **планируемым**.
- `start` ДОЛЖЕН быть строкой в формате `YYYY-MM-DD`.

### `duration` *(string)*

Длительность работы. Формат: `<число><единица>`, где:

- `d` — дни (например, `5d` = 5 рабочих дней)
- `w` — недели (например, `2w` = 2 недели)

**Семантика единицы `d` (дни):**

- `Nd` означает N **рабочих дней** по календарю представления.
- При пустом `excludes` → рабочий день = любой календарный день (т.е. `5d` = 5 календарных дней).
- При `excludes: ["weekends"]` → рабочий день = пн–пт (т.е. `5d` = 5 будних дней).

**Семантика единицы `w` (недели):**

- `1w` = 5 рабочих дней (не 7 календарных).
- При наличии `excludes: ["weekends"]` в представлении, неделя остаётся равной 5 рабочим дням.
- Пример: `2w` = 10 рабочих дней.

**Правила:**

- Число ДОЛЖНО быть положительным целым (≥ 1).
- Формат ДОЛЖЕН соответствовать регулярному выражению: `^[1-9][0-9]*[dw]$`.
- `duration` без `start` или `after` не определяет позицию на временной шкале, но может использоваться для оценки трудозатрат.

**Значение по умолчанию:**

- Если `duration` не указан для планируемого узла (имеющего `start` или вычислимый `start` через `after`), core-инструменты ДОЛЖНЫ использовать значение `1d` по умолчанию.
- Это обеспечивает возможность вычисления `finish` и `start from after` для всех планируемых узлов.

### `finish` *(string, YYYY-MM-DD)*

Целевая дата завершения или дедлайн. Формат: ISO 8601 дата, например `2024-03-15`.

**Поведение:**

1. **Если указаны `finish` и `duration`, но нет `start`:**
   - `start` вычисляется "назад" от `finish` путём вычитания рабочих дней.
   - Пример: `finish: 2024-03-15`, `duration: 5d` → `start: 2024-03-11` (или раньше, если есть excludes).

2. **Если указаны `start` и `finish`, но нет `duration`:**
   - `duration` вычисляется как количество рабочих дней между датами.
   - Пример: `start: 2024-03-11`, `finish: 2024-03-15` → `duration: 5d` (без excludes).

3. **Если указаны все три (`start`, `finish`, `duration`):**
   - Они ДОЛЖНЫ быть согласованы (вычисленный `finish` из `start+duration` должен совпадать с указанным `finish`).
   - Несогласованность является **ошибкой**.

**Пример:**

```yaml
nodes:
  release_prep:
    title: "Подготовка к релизу"
    finish: "2024-03-15"  # Дедлайн
    duration: "5d"
    # start вычисляется назад: 2024-03-11 (5 рабочих дней: 11, 12, 13, 14, 15)
```

### `after` *(list[string])*

Список ID узлов-зависимостей.

**Семантика:** узел может стартовать только после завершения **всех** узлов из списка `after`.

## Вычисление дат

### Дата окончания (finish)

Дата окончания вычисляется по формуле:

```
finish = start + (duration_days - 1)
```

где `duration_days` — длительность в рабочих днях.

**Пояснение:** день начала (`start`) включается в длительность. Узел с `duration: 1d` начинается и заканчивается в один день.

**Примеры:**

| start | duration | finish | Пояснение |
|-------|----------|--------|-----------|
| 2024-03-01 | 1d | 2024-03-01 | Один день работы |
| 2024-03-01 | 5d | 2024-03-05 | Пять дней: 01, 02, 03, 04, 05 |
| 2024-03-01 (пт) | 5d (без excludes) | 2024-03-05 | Календарные дни |
| 2024-03-01 (пт) | 5d (с excludes: weekends) | 2024-03-07 | Рабочие дни: пт, пн, вт, ср, чт |

### Вычисление start из after

Если `start` не указан, но указан `after`, дата старта вычисляется как:

```
start = max(finish для всех зависимостей) + 1 рабочий день
```

**Алгоритм:**

1. Для каждой зависимости из `after` вычислить её `finish`.
2. Найти максимальную дату `finish` среди всех зависимостей.
3. Добавить 1 рабочий день (с учётом `excludes`, если применимо).

**Пример (без excludes — календарные дни):**

```yaml
nodes:
  task_a:
    title: "Задача A"
    start: "2024-03-04"    # Понедельник
    duration: "3d"
    # finish = 2024-03-06 (пн, вт, ср)

  task_b:
    title: "Задача B"
    after: [task_a]
    duration: "2d"
    # start = 2024-03-07 (чт), finish = 2024-03-08 (пт)
```

### Особое правило для вех (milestones)

Если узел с `after` является вехой (`milestone: true`), дата старта вычисляется **без добавления следующего рабочего дня**:

```
start = max(finish для всех зависимостей)
```

Это связано с тем, что веха фиксирует момент завершения предшествующих работ, а не начало новой работы.

**Пример:**

```yaml
nodes:
  feature:
    title: "Разработка фичи"
    start: "2024-03-01"
    duration: "5d"
    # finish = 2024-03-05

  release:
    title: "Релиз"
    milestone: true
    after: [feature]
    # start = 2024-03-05 (НЕ 2024-03-06!)
    # Веха фиксирует момент завершения feature
```

**Сравнение:**

| Тип узла | Формула start из after |
|----------|------------------------|
| Обычный узел | `next_workday(max_finish)` |
| Веха (`milestone: true`) | `max_finish` |

### Одновременное наличие start и after

Если узел имеет и `start`, и `after`:

- **`start` имеет приоритет** — используется явно указанная дата.
- **`after` становится логической зависимостью** — отображается как связь (стрелка) на диаграмме, но не влияет на дату старта.

**Пример:**

```yaml
nodes:
  dependency:
    title: "Зависимость"
    start: "2024-03-01"
    duration: "5d"
    # finish = 2024-03-05

  task_with_both:
    title: "Задача с явным стартом"
    start: "2024-03-04"  # Явная дата (раньше finish зависимости!)
    after: [dependency]   # Логическая связь для диаграммы
    duration: "3d"
    # start = 2024-03-04 (используется явный start, не вычисленный)
    # finish = 2024-03-06
```

В этом примере `task_with_both` начнётся 04.03, хотя `dependency` заканчивается 05.03. Это может быть намеренным (например, параллельная работа) или ошибкой в планировании — инструменты МОГУТ выдавать предупреждение.

### Нормализация start на исключённый день

Если `start` узла попадает на исключённый день (например, выходной или праздник) и узел НЕ является вехой:

1. Планировщик ДОЛЖЕН нормализовать `start` на следующий рабочий день.
2. Планировщик ДОЛЖЕН выдать предупреждение: "start попал на исключённый день, нормализован на следующий рабочий день".
3. Для вычислений используется нормализованный `effective_start`, а не исходный `start`.

**Пример:**

```yaml
# В представлении: excludes: ["weekends", "2024-03-08"]

nodes:
  task:
    title: "Задача с началом в выходной"
    start: "2024-03-02"  # Суббота
    duration: "3d"
    # Effective start: 2024-03-04 (понедельник)
    # Предупреждение: "start 2024-03-02 — исключённый день, нормализован на 2024-03-04"
    # finish = 2024-03-06 (3 рабочих дня от понедельника)
```

**Для вех:** нормализация НЕ применяется. Вехи могут быть привязаны к любой дате, включая исключённые дни.

### Поле finish на исключённом дне

Если `finish` узла попадает на исключённый день (выходной или праздник):

1. **Для обычных задач**: инструмент ДОЛЖЕН выдать предупреждение "finish попал на исключённый день".
   - `finish` **НЕ нормализуется автоматически** (в отличие от `start`).
   - Это позволяет использовать `finish` как "дедлайн" на конкретную календарную дату.

2. **Для вех**: предупреждение НЕ выдаётся. Вехи могут быть привязаны к любой дате.

3. **При вычислении зависимостей** (`after`): если зависимость имеет `finish` на исключённом дне, функция `next_workday(finish)` корректно найдёт следующий рабочий день, пропуская исключённые дни.

**Пример:**

```yaml
# В представлении: excludes: ["weekends"]

nodes:
  urgent_task:
    title: "Срочная задача"
    start: "2024-03-04"  # Понедельник
    finish: "2024-03-09"  # Суббота — ПРЕДУПРЕЖДЕНИЕ: finish на исключённом дне
    # duration вычисляется по рабочим дням между 04 и 09 = 5d (пн-пт)
    
  next_task:
    title: "Следующая задача"
    after: [urgent_task]
    duration: "2d"
    # start = next_workday(2024-03-09) = 2024-03-11 (понедельник)
```

### Вычисление start из finish (обратное планирование)

Если `start` не указан, но указаны `finish` и `duration`:

1. Вычислить количество рабочих дней из `duration`.
2. Вычесть рабочие дни от `finish`, двигаясь назад.
3. Результат — вычисленный `start`.

**Алгоритм:**

```
start = sub_workdays(finish, duration_days - 1)
```

где `sub_workdays(finish, n)` идёт назад на n рабочих дней от finish, пропуская исключённые дни.

**Пример:**

```yaml
# В представлении: excludes: ["weekends"]

nodes:
  release_prep:
    title: "Подготовка к релизу"
    finish: "2024-03-15"  # Пятница
    duration: "5d"
    # Идём назад на 5 рабочих дней: пт(15), чт(14), ср(13), вт(12), пн(11)
    # start = 2024-03-11 (понедельник)
```

### Непланируемые узлы

Узел считается **непланируемым**, если:

1. Отсутствует `start`, И
2. Отсутствует `after`, ИЛИ все зависимости в `after` сами непланируемые.

**Core-поведение:** непланируемые узлы НЕ отображаются на временной шкале Gantt. Это нормативное правило для всех инструментов.

> **Примечание:** рендереры МОГУТ предоставлять расширения (например, `x.scheduling.anchor_to_parent_start`) для опционального наследования дат от родительских узлов. Такие расширения являются non-core и ДОЛЖНЫ быть документированы отдельно.

## Исключения календаря (excludes)

Параметр `excludes` задаётся на уровне представления (`gantt_views`) и влияет на расчёт дат.

### Core excludes (влияют на расчёт)

Следующие значения в `excludes` являются **core** и ДОЛЖНЫ влиять на вычисление дат в переносимых инструментах:

1. `"weekends"` — исключить субботу и воскресенье из рабочих дней.
2. **Конкретные даты в формате `YYYY-MM-DD`** — исключить указанные дни (праздники, закрытия офиса и т.п.).

**Пример:**

```yaml
gantt_views:
  main:
    excludes:
      - weekends
      - "2024-03-08"  # Международный женский день (праздник)
      - "2024-05-01"  # День труда
```

### Non-core excludes

Любые другие значения в `excludes` (например, `"monday"`, произвольные токены) являются **non-core**:

- Переносимые инструменты ДОЛЖНЫ игнорировать их.
- Переносимые инструменты ДОЛЖНЫ выдавать предупреждение: "неизвестное значение exclude '<value>' является non-core и игнорируется".
- Рендерер-специфичные инструменты МОГУТ поддерживать их как расширения (ДОЛЖНО быть документировано).

**Почему это важно:** это предотвращает расхождение календарей, когда разные инструменты вычисляют разные расписания для одного и того же плана.

### Влияние на вычисления

При наличии core excludes:

1. **`"weekends"`**: суббота и воскресенье пропускаются в вычислениях рабочих дней.
2. **Даты `YYYY-MM-DD`**: указанные даты пропускаются в вычислениях рабочих дней.
3. **Длительность** считается в рабочих днях (исключая выходные и указанные даты).
4. **Дата окончания** пропускает исключённые дни.
5. **Следующий рабочий день** после зависимости пропускает исключённые дни.

**Пример с праздником:**

```yaml
# В представлении: excludes: ["weekends", "2024-03-08"]

nodes:
  task:
    title: "Задача с праздником"
    start: "2024-03-07"  # Четверг
    duration: "3d"
    # Рабочие дни: чт(07), пропуск пт(08, праздник), пропуск сб-вс, пн(11), вт(12)
    # finish = 2024-03-12 (вторник)
```

**Пример с weekends:**

```yaml
# В представлении: excludes: ["weekends"]

nodes:
  friday_task:
    title: "Начало в пятницу"
    start: "2024-03-01"  # Пятница
    duration: "3d"
    # Рабочие дни: пт (01), пн (04), вт (05)
    # finish = 2024-03-05 (вторник)

  next_task:
    title: "После friday_task"
    after: [friday_task]
    duration: "2d"
    # start = 2024-03-06 (среда)
    # finish = 2024-03-07 (четверг)
```

## Примеры

### Узел с фиксированной датой старта

```yaml
nodes:
  kickoff:
    title: "Kickoff"
    start: "2024-03-01"
    duration: "1d"
```

### Узел с зависимостью

```yaml
nodes:
  design:
    title: "Дизайн"
    start: "2024-03-01"
    duration: "5d"

  implementation:
    title: "Реализация"
    after: [design]
    duration: "10d"
```

В этом примере `implementation` может начаться только после завершения `design`.

### Узел с несколькими зависимостями

```yaml
nodes:
  backend:
    title: "Backend API"
    start: "2024-03-01"
    duration: "5d"

  frontend:
    title: "Frontend UI"
    start: "2024-03-01"
    duration: "3d"

  integration:
    title: "Интеграция"
    after: [backend, frontend]
    duration: "2d"
```

Узел `integration` ждёт завершения **обоих** узлов `backend` и `frontend`. Его `start` будет вычислен как следующий день после `max(finish(backend), finish(frontend))`.

### Узел с duration в неделях

```yaml
nodes:
  sprint:
    title: "Спринт разработки"
    start: "2024-03-04"  # Понедельник
    duration: "2w"       # = 10 рабочих дней
    # finish = 2024-03-15 (пятница второй недели)
```

## Взаимодействие с представлениями

Поля планирования используются рендерерами для построения временных диаграмм:

- **Gantt-диаграммы**: `start` и `duration` определяют позицию и длину полосы узла на временной шкале.
- **Зависимости**: `after` отображается как стрелки между узлами.
- **Исключения календаря**: параметр `excludes` в `gantt_views` влияет на расчёт дат при наличии `duration`.

## Канонический алгоритм планирования (псевдокод)

Этот раздел определяет канонический алгоритм вычисления расписания. Независимые реализации, следующие этому алгоритму, ДОЛЖНЫ давать идентичные результаты.

### Примитивы

```python
def is_workday(d: date, excludes: list) -> bool:
    """Проверяет, является ли дата рабочим днём (не исключённым)."""
    # Проверка выходных
    if "weekends" in excludes and d.weekday() in [5, 6]:  # Sat=5, Sun=6
        return False
    
    # Проверка конкретных дат (YYYY-MM-DD)
    if d.isoformat() in excludes:  # формат YYYY-MM-DD
        return False
    
    return True


def next_workday(d: date, excludes: list) -> date:
    """Находит следующий рабочий день после d (d+1, пропуская исключённые дни)."""
    cur = d + timedelta(days=1)
    while not is_workday(cur, excludes):
        cur += timedelta(days=1)
    return cur


def add_workdays(start: date, n: int, excludes: list) -> date:
    """Добавляет n рабочих дней к start."""
    cur = start
    added = 0
    while added < n:
        cur += timedelta(days=1)
        if is_workday(cur, excludes):
            added += 1
    return cur


def sub_workdays(finish: date, n: int, excludes: list) -> date:
    """Вычитает n рабочих дней из finish (идёт назад)."""
    cur = finish
    subtracted = 0
    while subtracted < n:
        cur -= timedelta(days=1)
        if is_workday(cur, excludes):
            subtracted += 1
    return cur


def normalize_start(start: date, excludes: list, is_milestone: bool) -> date:
    """Нормализует start на следующий рабочий день, если попал на исключённый день."""
    if is_milestone:
        return start  # Вехи не нормализуются
    if not is_workday(start, excludes):
        # Найти следующий рабочий день
        cur = start
        while not is_workday(cur, excludes):
            cur += timedelta(days=1)
        # SHOULD выдать предупреждение: "start попал на исключённый день, нормализован"
        return cur
    return start


def compute_start_from_after(dependencies_finishes: list[date], excludes: list, is_milestone: bool) -> date:
    """Вычисляет start для узла с зависимостями after."""
    max_finish = max(dependencies_finishes)
    if is_milestone:
        # Вехи начинаются в день завершения зависимостей
        return max_finish
    else:
        # Обычные узлы начинаются на следующий рабочий день
        return next_workday(max_finish, excludes)
```

### Приоритет вычисления start

При вычислении `start` для узла используется следующий приоритет:

1. **Явный `start`** (если указан): использовать его (после нормализации, если попал на исключённый день).
2. **Явный `finish` + `duration`** (если `start` отсутствует): вычислить `start = sub_workdays(finish, duration - 1)`.
3. **Зависимости `after`** (если `start` и `finish` отсутствуют):
   - Для **обычных узлов**: `start = next_workday(max_finish_зависимостей)`.
   - Для **вех** (`milestone: true`): `start = max_finish_зависимостей` (без +1 день).
4. **Иначе**: узел непланируемый (нет start).

### Проверка согласованности

Если указаны все три поля (`start`, `finish`, `duration`):

```python
computed_finish = add_workdays(start, duration - 1, excludes)
if computed_finish != finish:
    # ОШИБКА: несогласованные start/finish/duration
```

### Зависимости вне представления

При вычислении расписания для представления, разрешение зависимостей (`after`) ДОЛЖНО учитывать ВСЕ узлы в плане, даже если они не отображаются в текущем представлении.

**Почему:** это гарантирует, что "срезы" плана на несколько представлений не ломают цепочки зависимостей.

## Миграция из модели с `end` (exclusive)

Некоторые системы планирования используют `end` как эксклюзивную границу интервала (т.е. работа идёт ДО указанной даты, но не включая её). opskarta использует `finish` как **инклюзивную** дату — работа включает день `finish`.

### Формула преобразования

```
finish_opskarta = prev_workday(end_exclusive, calendar)
```

где `prev_workday` находит предыдущий рабочий день с учётом календаря представления (excludes).

**Важно:** нельзя просто вычесть 1 календарный день. Нужно найти **предыдущий рабочий день** с учётом исключений календаря.

### Пример

| Исходная модель | opskarta |
|-----------------|----------|
| `end: 2024-03-18` (пн, exclusive) | `finish: 2024-03-15` (пт, inclusive) |
| Работа идёт до 18-го, не включая | Работа заканчивается 15-го (пятница) |

При `excludes: ["weekends"]`, если `end = 2024-03-18` (понедельник), то `finish = 2024-03-15` (пятница), потому что 16-17 — выходные.

### Алгоритм

```python
def prev_workday(d: date, excludes: list) -> date:
    """Находит предыдущий рабочий день (d-1, пропуская исключённые дни назад)."""
    cur = d - timedelta(days=1)
    while not is_workday(cur, excludes):
        cur -= timedelta(days=1)
    return cur


def convert_end_to_finish(end_exclusive: date, excludes: list) -> date:
    """Преобразует end (exclusive) в finish (inclusive)."""
    return prev_workday(end_exclusive, excludes)
```

### Проверка корректности миграции

После миграции убедитесь, что:

1. Количество рабочих дней (`duration`) осталось неизменным.
2. Зависимые задачи (`after`) начинаются в тот же день, что и раньше.
3. Вехи, привязанные к дедлайнам, корректно указывают на нужную дату.
