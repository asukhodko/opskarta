<!-- Этот файл сгенерирован автоматически. Не редактируйте вручную! -->
<!-- Для изменений редактируйте файлы в spec/ и запустите: python tools/build_spec.py -->

## Оглавление

- [Спецификация opskarta v1 (черновик)](#спецификация-opskarta-v1-черновик)
- [Файл плана (`*.plan.yaml`)](#файл-плана-planyaml)
- [Узлы (`nodes`)](#узлы-nodes)
- [Файл представлений (`*.views.yaml`)](#файл-представлений-viewsyaml)
- [Статусы (`statuses`)](#статусы-statuses)
- [Планирование (`start`, `duration`, `after`, `excludes`)](#планирование-start-duration-after-excludes)
- [Рекомендации по кодированию YAML](#рекомендации-по-кодированию-yaml)
- [Правила валидации](#правила-валидации)
- [Расширяемость](#расширяемость)
- [Renderer profile: Mermaid Gantt](#renderer-profile-mermaid-gantt)

# Спецификация opskarta v1 (черновик)

Эта спецификация описывает *минимальный* совместимый набор полей формата opskarta.

- Формат сериализации: **YAML** (рекомендовано) или JSON.
- Версионирование: поле `version` в корне документа.
- Идентификаторы узлов: строковые ключи в мапе `nodes:`.

> Статус: **Draft**. Спека намеренно стартует маленькой и расширяемой.

## Core vs Non-core

Спецификация различает **core** (нормативные) и **non-core** (информативные/расширения) части:

| Категория | Описание | Обязательность для инструментов |
|-----------|----------|--------------------------------|
| **Core** | Базовая семантика формата, алгоритмы планирования, правила валидации | MUST implement |
| **Non-core** | Расширения (`x:` namespace), renderer profiles, дополнительные поля представлений | MAY implement |

### Core-компоненты

- Структура файлов `*.plan.yaml` и `*.views.yaml`
- Поля узлов: `title`, `kind`, `status`, `parent`, `after`, `start`, `duration`, `milestone`
- Вычисление дат: `finish`, `start from after`
- Исключения календаря: `"weekends"` в `excludes`
- Значение по умолчанию: `duration = 1d` для планируемых узлов
- Правила валидации и ссылочной целостности

### Non-core компоненты

- Расширения через `x:` namespace (например, `x.scheduling.anchor_to_parent_start`)
- Renderer profiles (Mermaid Gantt, другие)
- Поля представлений для конкретных рендереров (`date_format`, `axis_format`, `tick_interval`)
- Конкретные даты в `excludes` (передаются рендереру, но не влияют на core-алгоритм)
- Цвета статусов по умолчанию

---

# Файл плана (`*.plan.yaml`)

## Корневые поля

- `version` *(int)* — версия схемы.
- `meta` *(object)* — метаданные плана.
  - `id` *(string)* — ID проекта/программы. Используется для связки с файлами представлений.
  - `title` *(string)* — человекочитаемое имя.
- `statuses` *(object)* — словарь статусов.
- `nodes` *(object)* — словарь узлов работ: `{ <node_id>: <node> }`.

## Пример

```yaml
version: 1
meta:
  id: demo
  title: "Demo"

statuses:
  not_started: { label: "Не начато", color: "#9ca3af" }
  in_progress: { label: "В работе",  color: "#0ea5e9" }

nodes:
  root:
    title: "Root"
    kind: summary
    status: in_progress
```

---

# Узлы (`nodes`)

Узел — это единица работ/смысла в твоей карте.

## Идентификаторы узлов (node_id)

Каждый узел идентифицируется ключом в словаре `nodes`. Этот ключ (`node_id`) используется для ссылок в `parent`, `after` и `lanes[].nodes`.

### Требования

- `node_id` ДОЛЖЕН быть уникальным в пределах `nodes`.
- `node_id` ДОЛЖЕН быть строкой.

### Рекомендации

- **Рекомендуемый формат:** `^[a-zA-Z][a-zA-Z0-9._-]*$`
  - Начинается с буквы
  - Содержит только буквы, цифры, точки, подчёркивания, дефисы
- **Для совместимости с Mermaid:** избегайте пробелов, скобок, двоеточий в идентификаторах.

```yaml
# Хорошие идентификаторы
nodes:
  kickoff: ...
  phase_1: ...
  backend-api: ...
  JIRA.123: ...

# Проблемные идентификаторы (могут не работать в некоторых рендерерах)
nodes:
  "task with spaces": ...     # Пробелы
  "task:important": ...       # Двоеточие
  123: ...                    # Начинается с цифры
```

## Обязательные поля узла

- `title` *(string)* — имя работы.

## Рекомендуемые поля

- `kind` *(string)* — тип узла. Рекомендованные значения:
  - `summary` — верхнеуровневый контейнер
  - `phase` — этап/фаза
  - `epic` — крупная сущность в системе деталей
  - `user_story` — история/ценность
  - `task` — конкретная задача

- `status` *(string)* — ключ статуса из `statuses`.

- `parent` *(string)* — ID родительского узла (иерархия декомпозиции).

- `after` *(list[string])* — зависимости "после чего" (граф).  
  Семантика: узел может стартовать после завершения всех `after`.

- Планирование:
  - `start` *(YYYY-MM-DD)* — плановая дата старта
  - `duration` *(string)* — длительность, например `5d`. Если не указана для планируемого узла — по умолчанию `1d`.
  - `milestone` *(boolean)* — если `true`, узел является вехой (событием-точкой). См. ниже.

- `issue` *(string)* — ссылка/ключ в системе деталей (например, `JIRA-123`).

- `notes` *(string|multiline)* — заметки/контекст, который не хочется терять.

## Вехи (milestones)

Веха — это событие-точка на временной шкале, а не задача с длительностью. Используется для фиксации ключевых дат: релизы, дедлайны, контрольные точки.

### Поле `milestone`

- `milestone` *(boolean)* — если `true`, узел отображается как веха.

### Поведение

- Веха ДОЛЖНА иметь `start` или вычислимый `start` через `after`.
- Если `duration` не указан для вехи, используется `1d` для вычислений.
- На диаграмме Gantt веха отображается как точка/ромб, а не как полоса.
- Вехи могут иметь зависимости (`after`) и статусы (`status`).

### Пример

```yaml
nodes:
  release_v1:
    title: "Релиз v1.0"
    milestone: true
    start: "2024-03-15"
    status: not_started

  beta_release:
    title: "Бета-релиз"
    milestone: true
    after: [integration_testing]
    # start вычисляется из after
```

## Примечания

- opskarta не диктует workflow. `status` — это метка для твоей карты.
- Узел может существовать без `issue` (черновик, гипотеза, заготовка).

---

# Файл представлений (`*.views.yaml`)

Файл представлений описывает, *как* смотреть на план.

## Корневые поля

- `version` *(int)*
- `project` *(string)* — должен совпадать с `meta.id` плана
- `gantt_views` *(object)* — набор Gantt‑представлений (опционально)

## Gantt view

### Core-поля

- `title` *(string)* — заголовок представления
- `excludes` *(list[string])* — исключения календаря
  - `"weekends"` — исключить субботу и воскресенье (core)
  - Конкретные даты в формате `YYYY-MM-DD` — подсказки для рендерера (non-core)
- `lanes` *(object)* — полосы/лейны
  - `<lane_id>.title` *(string)*
  - `<lane_id>.nodes` *(list[string])* — список node_id, которые показываем в этом лейне

### Поля для рендерера Mermaid (non-core)

Следующие поля являются расширениями для Mermaid Gantt рендерера и НЕ влияют на core-алгоритм вычисления дат:

- `date_format` *(string)* — формат входных дат для Mermaid (по умолчанию `YYYY-MM-DD`)
- `axis_format` *(string)* — формат отображения дат на оси X
- `tick_interval` *(string)* — интервал меток на оси X (например, `1week`, `1day`, `1month`)

> **Примечание:** эти поля документированы здесь для совместимости с существующими файлами. Подробное описание маппинга на директивы Mermaid см. в разделе "Renderer profile: Mermaid Gantt".

## Пример

### Минимальный

```yaml
version: 1
project: demo

gantt_views:
  overview:
    title: "Overview"
    excludes: ["weekends"]
    lanes:
      main:
        title: "Main"
        nodes: [root, task1]
```

### Расширенный (с полями для Mermaid)

```yaml
version: 1
project: demo

gantt_views:
  overview:
    title: "Обзор проекта"
    date_format: "YYYY-MM-DD"
    axis_format: "%d %b"
    tick_interval: "1week"
    excludes:
      - weekends
      - "2024-03-08"    # Праздник
    lanes:
      development:
        title: "Разработка"
        nodes: [backend, frontend, integration]
      testing:
        title: "Тестирование"
        nodes: [unit_tests, e2e_tests]
```

---

# Статусы (`statuses`)

`statuses` — словарь произвольных статусов, которые понимает твой набор инструментов.

## Структура

Секция `statuses` в файле плана является **опциональной**. Однако, если хотя бы один узел имеет поле `status`, секция `statuses` становится обязательной.

### Правило ссылочной целостности

Если узел имеет поле `status`, значение ДОЛЖНО быть ключом из словаря `statuses`:

```yaml
statuses:
  done: { label: "Готово" }
  in_progress: { label: "В работе" }

nodes:
  task1:
    title: "Задача"
    status: done          # ✓ корректно
  task2:
    title: "Другая задача"
    status: pending       # ✗ ошибка: pending нет в statuses
```

## Рекомендованные ключи статусов

Следующие ключи не обязательны, но помогают совместимости между инструментами:

- `not_started`
- `in_progress`
- `done`
- `blocked`

## Поля статуса

Каждый статус — объект со следующими полями:

| Поле | Тип | Обязательность | Описание |
|------|-----|----------------|----------|
| `label` | string | Рекомендуется | Человекочитаемое имя статуса |
| `color` | string | Опционально | Цвет в hex-формате для визуализаций |

### Поле `label`

- Если `label` не указан, рендереры МОГУТ использовать ключ статуса как label.

### Поле `color`

- Формат: hex-цвет, регулярное выражение `^#[0-9a-fA-F]{6}$`.
- Примеры: `#22c55e`, `#9ca3af`, `#fecaca`.
- Если `color` не указан, рендереры МОГУТ использовать цвета по умолчанию (см. Renderer profile).

```yaml
# Корректные цвета
color: "#22c55e"
color: "#9CA3AF"

# Некорректные цвета
color: "green"      # Именованные цвета не поддерживаются
color: "#fff"       # Должен быть 6-символьный hex
color: "22c55e"     # Должен начинаться с #
```

## Пример

### Минимальный

```yaml
statuses:
  done: { label: "Готово" }
  in_progress: { label: "В работе" }
```

### Полный

```yaml
statuses:
  not_started:
    label: "Не начато"
    color: "#9ca3af"
  in_progress:
    label: "В работе"
    color: "#0ea5e9"
  done:
    label: "Готово"
    color: "#22c55e"
  blocked:
    label: "Заблокировано"
    color: "#fecaca"
```

---

# Планирование (`start`, `duration`, `after`, `excludes`)

Поля планирования позволяют задать временные характеристики узлов и зависимости между ними.

## Термины

- **Календарь представления (calendar(view))** — функция, определяющая, какие дни считаются рабочими для данного представления. Зависит от параметра `excludes` в представлении.
- **Рабочий день (workday)** — день, который НЕ исключён календарём представления. При `excludes: ["weekends"]` рабочими являются пн–пт. При пустом `excludes` рабочим является любой календарный день.
- **Планируемый узел (scheduled)** — узел, для которого можно вычислить дату начала (`start`). Такие узлы отображаются на временной шкале.
- **Непланируемый узел (unscheduled)** — узел без явного `start` и без вычислимого `start` через `after`. Такие узлы НЕ отображаются на временной шкале.

> **Важно:** расписание вычисляется для каждого представления отдельно. План хранит ограничения (constraints), представления применяют правила календаря. Один и тот же узел может иметь разные вычисленные даты в разных представлениях с разными `excludes`.

## Поля планирования

### `start` *(string, YYYY-MM-DD)*

Плановая дата начала работы. Формат: ISO 8601 дата, например `2024-03-15`.

- Если указан `start`, узел считается **планируемым**.
- `start` ДОЛЖЕН быть строкой в формате `YYYY-MM-DD`.

### `duration` *(string)*

Длительность работы. Формат: `<число><единица>`, где:

- `d` — дни (например, `5d` = 5 рабочих дней)
- `w` — недели (например, `2w` = 2 недели)

**Семантика единицы `d` (дни):**

- `Nd` означает N **рабочих дней** по календарю представления.
- При пустом `excludes` → рабочий день = любой календарный день (т.е. `5d` = 5 календарных дней).
- При `excludes: ["weekends"]` → рабочий день = пн–пт (т.е. `5d` = 5 будних дней).

**Семантика единицы `w` (недели):**

- `1w` = 5 рабочих дней (не 7 календарных).
- При наличии `excludes: ["weekends"]` в представлении, неделя остаётся равной 5 рабочим дням.
- Пример: `2w` = 10 рабочих дней.

**Правила:**

- Число ДОЛЖНО быть положительным целым (≥ 1).
- Формат ДОЛЖЕН соответствовать регулярному выражению: `^[1-9][0-9]*[dw]$`.
- `duration` без `start` или `after` не определяет позицию на временной шкале, но может использоваться для оценки трудозатрат.

**Значение по умолчанию:**

- Если `duration` не указан для планируемого узла (имеющего `start` или вычислимый `start` через `after`), core-инструменты ДОЛЖНЫ использовать значение `1d` по умолчанию.
- Это обеспечивает возможность вычисления `finish` и `start from after` для всех планируемых узлов.

### `after` *(list[string])*

Список ID узлов-зависимостей.

**Семантика:** узел может стартовать только после завершения **всех** узлов из списка `after`.

## Вычисление дат

### Дата окончания (finish)

Дата окончания вычисляется по формуле:

```
finish = start + (duration_days - 1)
```

где `duration_days` — длительность в рабочих днях.

**Пояснение:** день начала (`start`) включается в длительность. Узел с `duration: 1d` начинается и заканчивается в один день.

**Примеры:**

| start | duration | finish | Пояснение |
|-------|----------|--------|-----------|
| 2024-03-01 | 1d | 2024-03-01 | Один день работы |
| 2024-03-01 | 5d | 2024-03-05 | Пять дней: 01, 02, 03, 04, 05 |
| 2024-03-01 (пт) | 5d (без excludes) | 2024-03-05 | Календарные дни |
| 2024-03-01 (пт) | 5d (с excludes: weekends) | 2024-03-07 | Рабочие дни: пт, пн, вт, ср, чт |

### Вычисление start из after

Если `start` не указан, но указан `after`, дата старта вычисляется как:

```
start = max(finish для всех зависимостей) + 1 рабочий день
```

**Алгоритм:**

1. Для каждой зависимости из `after` вычислить её `finish`.
2. Найти максимальную дату `finish` среди всех зависимостей.
3. Добавить 1 рабочий день (с учётом `excludes`, если применимо).

**Пример (без excludes — календарные дни):**

```yaml
nodes:
  task_a:
    title: "Задача A"
    start: "2024-03-04"    # Понедельник
    duration: "3d"
    # finish = 2024-03-06 (пн, вт, ср)

  task_b:
    title: "Задача B"
    after: [task_a]
    duration: "2d"
    # start = 2024-03-07 (чт), finish = 2024-03-08 (пт)
```

### Одновременное наличие start и after

Если узел имеет и `start`, и `after`:

- **`start` имеет приоритет** — используется явно указанная дата.
- **`after` становится логической зависимостью** — отображается как связь (стрелка) на диаграмме, но не влияет на дату старта.

**Пример:**

```yaml
nodes:
  dependency:
    title: "Зависимость"
    start: "2024-03-01"
    duration: "5d"
    # finish = 2024-03-05

  task_with_both:
    title: "Задача с явным стартом"
    start: "2024-03-04"  # Явная дата (раньше finish зависимости!)
    after: [dependency]   # Логическая связь для диаграммы
    duration: "3d"
    # start = 2024-03-04 (используется явный start, не вычисленный)
    # finish = 2024-03-06
```

В этом примере `task_with_both` начнётся 04.03, хотя `dependency` заканчивается 05.03. Это может быть намеренным (например, параллельная работа) или ошибкой в планировании — инструменты МОГУТ выдавать предупреждение.

### Непланируемые узлы

Узел считается **непланируемым**, если:

1. Отсутствует `start`, И
2. Отсутствует `after`, ИЛИ все зависимости в `after` сами непланируемые.

**Core-поведение:** непланируемые узлы НЕ отображаются на временной шкале Gantt. Это нормативное правило для всех инструментов.

> **Примечание:** рендереры МОГУТ предоставлять расширения (например, `x.scheduling.anchor_to_parent_start`) для опционального наследования дат от родительских узлов. Такие расширения являются non-core и ДОЛЖНЫ быть документированы отдельно.

## Исключения календаря (excludes)

Параметр `excludes` задаётся на уровне представления (`gantt_views`) и влияет на расчёт дат.

### Поддерживаемые значения

- `"weekends"` — исключить субботу и воскресенье из рабочих дней.

### Влияние на вычисления

При наличии `excludes: ["weekends"]`:

1. **Длительность** считается в рабочих днях (пн-пт).
2. **Дата окончания** пропускает выходные.
3. **Следующий рабочий день** после зависимости пропускает выходные.

**Пример с weekends:**

```yaml
# В представлении: excludes: ["weekends"]

nodes:
  friday_task:
    title: "Начало в пятницу"
    start: "2024-03-01"  # Пятница
    duration: "3d"
    # Рабочие дни: пт (01), пн (04), вт (05)
    # finish = 2024-03-05 (вторник)

  next_task:
    title: "После friday_task"
    after: [friday_task]
    duration: "2d"
    # start = 2024-03-06 (среда)
    # finish = 2024-03-07 (четверг)
```

### Конкретные даты в excludes

Представления МОГУТ содержать конкретные даты в `excludes` (например, `["weekends", "2024-03-08"]`). Такие даты являются **подсказками для рендерера** и НЕ влияют на core-алгоритм вычисления дат.

## Примеры

### Узел с фиксированной датой старта

```yaml
nodes:
  kickoff:
    title: "Kickoff"
    start: "2024-03-01"
    duration: "1d"
```

### Узел с зависимостью

```yaml
nodes:
  design:
    title: "Дизайн"
    start: "2024-03-01"
    duration: "5d"

  implementation:
    title: "Реализация"
    after: [design]
    duration: "10d"
```

В этом примере `implementation` может начаться только после завершения `design`.

### Узел с несколькими зависимостями

```yaml
nodes:
  backend:
    title: "Backend API"
    start: "2024-03-01"
    duration: "5d"

  frontend:
    title: "Frontend UI"
    start: "2024-03-01"
    duration: "3d"

  integration:
    title: "Интеграция"
    after: [backend, frontend]
    duration: "2d"
```

Узел `integration` ждёт завершения **обоих** узлов `backend` и `frontend`. Его `start` будет вычислен как следующий день после `max(finish(backend), finish(frontend))`.

### Узел с duration в неделях

```yaml
nodes:
  sprint:
    title: "Спринт разработки"
    start: "2024-03-04"  # Понедельник
    duration: "2w"       # = 10 рабочих дней
    # finish = 2024-03-15 (пятница второй недели)
```

## Взаимодействие с представлениями

Поля планирования используются рендерерами для построения временных диаграмм:

- **Gantt-диаграммы**: `start` и `duration` определяют позицию и длину полосы узла на временной шкале.
- **Зависимости**: `after` отображается как стрелки между узлами.
- **Исключения календаря**: параметр `excludes` в `gantt_views` влияет на расчёт дат при наличии `duration`.

---

# Рекомендации по кодированию YAML

Формат opskarta использует YAML (рекомендуется) или JSON для сериализации. В этом разделе описаны рекомендации по корректному кодированию данных в YAML.

## Даты (поле `start`)

YAML-парсеры (особенно YAML 1.1, включая PyYAML по умолчанию) могут автоматически преобразовывать строки, похожие на даты, в специальные типы данных (date/datetime). Это может привести к неожиданному поведению.

### Настоятельно рекомендуемый формат

```yaml
nodes:
  task1:
    title: "Задача"
    start: "2024-03-15"  # Строка в кавычках — НАСТОЯТЕЛЬНО РЕКОМЕНДУЕТСЯ
    duration: "5d"
```

### Допустимый, но рискованный формат

```yaml
nodes:
  task1:
    title: "Задача"
    start: 2024-03-15  # Без кавычек — PyYAML 1.1 преобразует в тип date!
    duration: 5d       # Без кавычек — валидный plain scalar, но лучше в кавычках
```

> **Внимание:** `start: 2024-03-15` без кавычек в PyYAML будет преобразовано в Python `datetime.date(2024, 3, 15)`, а не в строку `"2024-03-15"`. Инструменты opskarta ДОЛЖНЫ нормализовать такие значения (см. раздел "Нормализация типов").

## Длительность (поле `duration`)

Значение `duration` ДОЛЖНО быть строкой в формате `<число><единица>` (например, `5d`, `2w`).

### Корректные примеры

```yaml
duration: "5d"   # 5 дней (рекомендуемый формат)
duration: "2w"   # 2 недели (= 10 рабочих дней)
duration: "10d"  # 10 дней
duration: 5d     # Валидный YAML plain scalar, парсится как строка "5d"
```

> **Примечание:** `5d` без кавычек является валидным YAML plain scalar и корректно парсится как строка. Кавычки рекомендуются для единообразия с полем `start`, но не обязательны.

### Некорректные примеры

```yaml
duration: 5      # Число без единицы — не соответствует формату
duration: "0d"   # Ноль недопустим
duration: "-1d"  # Отрицательные значения недопустимы
```

## Эквивалентность YAML и JSON

Формат данных opskarta является JSON-совместимым. YAML рекомендуется как более удобный синтаксис для ручного редактирования, но инструменты ДОЛЖНЫ приводить YAML-значения к каноническим типам opskarta (см. раздел "Нормализация типов").

> **Важно:** YAML является надмножеством JSON, но YAML 1.1 парсеры (например, PyYAML) имеют особенности авто-типизации, которые могут приводить к неожиданным результатам. Инструменты opskarta ДОЛЖНЫ корректно обрабатывать такие случаи.

### YAML

```yaml
version: 1
meta:
  id: "my-project"
  title: "Мой проект"
nodes:
  task1:
    title: "Первая задача"
    start: "2024-03-01"
    duration: "5d"
  task2:
    title: "Вторая задача"
    after:
      - task1
    duration: "3d"
```

### JSON (эквивалент)

```json
{
  "version": 1,
  "meta": {
    "id": "my-project",
    "title": "Мой проект"
  },
  "nodes": {
    "task1": {
      "title": "Первая задача",
      "start": "2024-03-01",
      "duration": "5d"
    },
    "task2": {
      "title": "Вторая задача",
      "after": ["task1"],
      "duration": "3d"
    }
  }
}
```

## Многострочные строки (поле `notes`)

Для многострочных заметок используйте литеральный блок (`|`) или свёрнутый блок (`>`):

### Литеральный блок (сохраняет переводы строк)

```yaml
nodes:
  task1:
    title: "Задача с заметками"
    notes: |
      Первая строка заметки.
      Вторая строка заметки.
      
      Абзац после пустой строки.
```

### Свёрнутый блок (объединяет строки)

```yaml
nodes:
  task1:
    title: "Задача с заметками"
    notes: >
      Это длинная заметка, которая
      будет объединена в одну строку
      с пробелами между частями.
```

## Специальные символы

При использовании специальных символов в строках заключайте их в кавычки:

```yaml
nodes:
  task1:
    title: "Задача: важная!"      # Двоеточие требует кавычек
    issue: "JIRA-123"             # Без проблем
    notes: "Заметка с # символом" # Решётка требует кавычек
```

## Нормализация типов

Инструменты opskarta (валидаторы, рендереры) ДОЛЖНЫ нормализовать YAML-значения к каноническим типам opskarta:

### Канонические типы полей

| Поле | Канонический тип | Допустимый YAML-вход | Нормализация |
|------|------------------|----------------------|--------------|
| `start` | строка `YYYY-MM-DD` | строка или YAML-дата | `date(2024, 3, 15)` → `"2024-03-15"` |
| `duration` | строка `Nd` или `Nw` | строка | — |
| `node_id` (ключи в `nodes`) | строка | строка | — |

### Правила нормализации

1. **Поле `start`:**
   - Если YAML-парсер вернул объект типа `date` или `datetime`, инструмент ДОЛЖЕН преобразовать его в строку формата `YYYY-MM-DD`.
   - Пример: Python `datetime.date(2024, 3, 15)` → строка `"2024-03-15"`.

2. **Идентификаторы узлов (`node_id`):**
   - Ключи в словаре `nodes` ДОЛЖНЫ быть строками.
   - Если YAML-парсер вернул нестроковый ключ (например, число), инструмент МОЖЕТ преобразовать его в строку или отвергнуть с ошибкой.
   - Рекомендация: отвергать нестроковые ключи для явности.

3. **Общий принцип:**
   - Инструменты НЕ ДОЛЖНЫ падать на корректных YAML-файлах только из-за особенностей YAML-типизации.
   - Инструменты ДОЛЖНЫ приводить значения к каноническим типам перед дальнейшей обработкой.

### Пример нормализации в Python

```python
from datetime import date, datetime

def normalize_start(value):
    """Нормализует значение start к строке YYYY-MM-DD."""
    if isinstance(value, datetime):
        return value.date().isoformat()
    if isinstance(value, date):
        return value.isoformat()
    if isinstance(value, str):
        return value.strip()
    raise ValueError(f"Invalid start type: {type(value)}")
```

---

# Правила валидации

Этот раздел описывает правила валидации файлов плана и представлений.

## Валидация файла плана (`*.plan.yaml`)

### Обязательные поля

- `version` *(int)* — ДОЛЖЕН присутствовать в корне документа.
- `nodes` *(object)* — ДОЛЖЕН присутствовать (может быть пустым).
- Для каждого узла: `title` *(string)* — обязательное поле.

### Поле `meta.id`

- `meta.id` РЕКОМЕНДУЕТСЯ для всех файлов плана.
- `meta.id` ОБЯЗАТЕЛЕН, если файл плана используется совместно с файлом представлений (`*.views.yaml`).

```yaml
# Минимальный план (без views)
version: 1
nodes:
  task1:
    title: "Задача"

# План для использования с views (meta.id обязателен)
version: 1
meta:
  id: "my-project"
  title: "Мой проект"
nodes:
  task1:
    title: "Задача"
```

### Ссылочная целостность

#### Родительские ссылки (`parent`)

- Если узел содержит поле `parent`, значение ДОЛЖНО быть ключом существующего узла в `nodes`.
- Циклические ссылки через `parent` запрещены.

```yaml
# Корректно
nodes:
  root:
    title: "Root"
  child:
    title: "Child"
    parent: root  # root существует

# Ошибка: несуществующий parent
nodes:
  child:
    title: "Child"
    parent: nonexistent  # ошибка!
```

#### Зависимости (`after`)

- Каждый элемент списка `after` ДОЛЖЕН быть ключом существующего узла в `nodes`.
- Циклические зависимости через `after` запрещены.

```yaml
# Корректно
nodes:
  task1:
    title: "Task 1"
  task2:
    title: "Task 2"
    after: [task1]  # task1 существует

# Ошибка: несуществующая зависимость
nodes:
  task2:
    title: "Task 2"
    after: [missing_task]  # ошибка!
```

#### Статусы (`status`)

- Если узел содержит поле `status`, значение ДОЛЖНО быть ключом из словаря `statuses`.

```yaml
statuses:
  done: { label: "Готово" }

nodes:
  task:
    title: "Task"
    status: done  # корректно, done есть в statuses

# Ошибка: несуществующий статус
nodes:
  task:
    title: "Task"
    status: completed  # ошибка, если completed нет в statuses!
```

### Формат полей планирования

#### Поле `start`

- Если указан, ДОЛЖЕН соответствовать формату `YYYY-MM-DD`.
- Формат: регулярное выражение `^\d{4}-\d{2}-\d{2}$`.
- РЕКОМЕНДУЕТСЯ проверять корректность даты (существующий день календаря).

```yaml
# Корректно
start: "2024-03-15"

# Ошибки формата
start: "2024-3-15"   # месяц без ведущего нуля
start: "15-03-2024"  # неверный порядок
start: "2024/03/15"  # неверный разделитель
```

#### Поле `duration`

- Если указан, ДОЛЖЕН соответствовать формату `<число><единица>`.
- Формат: регулярное выражение `^[1-9][0-9]*[dw]$`.
- Единицы: `d` (дни), `w` (недели, где 1w = 5 рабочих дней).
- Число ДОЛЖНО быть положительным целым (≥ 1).

```yaml
# Корректно
duration: "5d"   # 5 дней
duration: "2w"   # 2 недели (10 рабочих дней)
duration: "10d"  # 10 дней

# Ошибки формата
duration: "0d"   # ноль недопустим
duration: "-1d"  # отрицательные недопустимы
duration: "5"    # отсутствует единица
duration: "5m"   # неизвестная единица
duration: "d5"   # неверный порядок
```

## Валидация файла представлений (`*.views.yaml`)

### Обязательные поля

- `version` *(int)* — ДОЛЖЕН присутствовать.
- `project` *(string)* — ДОЛЖЕН присутствовать.

### Связь с файлом плана

- Поле `project` ДОЛЖНО совпадать с `meta.id` соответствующего файла плана.
- Если в файле плана отсутствует `meta.id`, валидация связи ДОЛЖНА завершиться ошибкой.

```yaml
# plan.yaml
meta:
  id: my-project

# views.yaml
project: my-project  # должно совпадать с meta.id
```

### Ссылки на узлы в представлениях

- Каждый `node_id` в `lanes[].nodes` ДОЛЖЕН существовать в файле плана.

```yaml
# Если в плане есть nodes: {task1, task2}
gantt_views:
  overview:
    lanes:
      main:
        nodes: [task1, task2]  # корректно
        # nodes: [task1, task3]  # ошибка, task3 не существует
```

### Поле `excludes` в представлениях

- Поле `excludes` в `gantt_views` МОЖЕТ содержать:
  - `"weekends"` — влияет на алгоритм расчёта дат (см. раздел "Планирование").
  - Конкретные даты в формате `YYYY-MM-DD` — являются **подсказками для рендерера** и НЕ влияют на core-алгоритм вычисления дат.

```yaml
gantt_views:
  overview:
    excludes:
      - weekends        # core: влияет на расчёт дат
      - "2024-03-08"    # non-core: подсказка для рендерера (праздник)
```

> **Примечание:** валидатор МОЖЕТ выдавать информационное предупреждение о наличии конкретных дат в `excludes`, указывая, что они не влияют на core-алгоритм.

## Уровни валидации

Валидатор может работать на разных уровнях:

1. **Синтаксис** — корректность YAML/JSON.
2. **Схема** — соответствие JSON Schema (типы полей, обязательные поля, форматы).
3. **Семантика** — ссылочная целостность, бизнес-правила, корректность дат.

## Уровни серьёзности (severity)

Валидатор ДОЛЖЕН классифицировать проблемы по уровням серьёзности:

| Уровень | Описание | Поведение |
|---------|----------|-----------|
| **error** | Критическая ошибка, делающая файл невалидным | Валидация завершается неудачей (exit code ≠ 0) |
| **warn** | Потенциальная проблема, требующая внимания | Валидация успешна, но выводится предупреждение |
| **info** | Информационное сообщение | Валидация успешна |

### Классификация проблем

| Проблема | Уровень |
|----------|---------|
| Отсутствие обязательных полей (`version`, `nodes`, `title`) | error |
| Несуществующие ссылки (`parent`, `after`, `status`) | error |
| Циклические зависимости (`parent`, `after`) | error |
| Дубликаты `node_id` в `nodes` | error |
| Неверный формат `start` или `duration` | error |
| Неверный формат `color` в `statuses` | error |
| Явный `start` раньше завершения зависимостей (`after`) | warn |
| Отсутствие `duration` у планируемого узла | warn |
| Конкретные даты в `excludes` (не влияют на core-алгоритм) | info |
| Непланируемые узлы (не отображаются на диаграмме) | info |

## Дополнительные правила валидации

### Уникальность идентификаторов узлов

Каждый `node_id` (ключ в словаре `nodes`) ДОЛЖЕН быть уникальным.

> **Важно:** некоторые YAML-парсеры (например, PyYAML) молча берут последнее значение при дублировании ключей. Валидатор ДОЛЖЕН детектировать дубликаты насколько это возможно и выдавать ошибку.

```yaml
# Ошибка: дублирование node_id
nodes:
  task1:
    title: "Первая версия"
  task1:                    # ОШИБКА: дубликат ключа!
    title: "Вторая версия"
```

### Конфликт start и after

Если узел имеет и `start`, и `after`, и явный `start` раньше вычисленного завершения зависимостей — валидатор ДОЛЖЕН выдать предупреждение:

```yaml
nodes:
  dependency:
    title: "Зависимость"
    start: "2024-03-01"
    duration: "5d"
    # finish = 2024-03-05

  task:
    title: "Задача"
    start: "2024-03-03"     # WARN: раньше finish зависимости (2024-03-05)!
    after: [dependency]
    duration: "2d"
```

### Формат цвета в статусах

Поле `color` в `statuses` ДОЛЖНО быть валидным hex-цветом:

- Формат: регулярное выражение `^#[0-9a-fA-F]{6}$`.
- Примеры корректных значений: `#22c55e`, `#9CA3AF`, `#fecaca`.

```yaml
statuses:
  done:
    label: "Готово"
    color: "#22c55e"    # корректно
  
  invalid:
    label: "Неверный"
    color: "green"      # ОШИБКА: должен быть hex-формат
```

## Сообщения об ошибках

Валидатор ДОЛЖЕН предоставлять понятные сообщения об ошибках:

- Путь к проблемному полю (например, `nodes.task2.parent`).
- Описание проблемы.
- Ожидаемое значение или формат.

Пример вывода:

```
Error: Invalid reference in nodes.task2.parent
  Value: "nonexistent"
  Expected: existing node ID from nodes
  Available: root, task1
```

```
Error: Invalid duration format in nodes.task1.duration
  Value: "5"
  Expected: format <number><unit> where unit is 'd' or 'w'
  Pattern: ^[1-9][0-9]*[dw]$
```

---

# Расширяемость

opskarta специально допускает расширение формата без нарушения базовой совместимости.

## Области расширяемости

Дополнительные поля (расширения) допустимы в следующих местах:

### Файл плана (`*.plan.yaml`)

| Уровень | Пример расположения | Описание |
|---------|---------------------|----------|
| Корень файла | `version`, `meta`, `nodes`, **`x:`** | Метаданные проекта |
| Объект `meta` | `meta.id`, `meta.title`, **`meta.x:`** | Расширенные метаданные |
| Объект `statuses.*` | `statuses.done.label`, **`statuses.done.x:`** | Дополнительные атрибуты статуса |
| Объект узла `nodes.*` | `nodes.task1.title`, **`nodes.task1.x:`** | Пользовательские атрибуты узла |

### Файл представлений (`*.views.yaml`)

| Уровень | Пример расположения | Описание |
|---------|---------------------|----------|
| Корень файла | `version`, `project`, **`x:`** | Метаданные представлений |
| Объект `gantt_views.*` | `gantt_views.main.title`, **`gantt_views.main.x:`** | Настройки представления |
| Объект `lanes.*` | `lanes.dev.title`, **`lanes.dev.x:`** | Настройки дорожки |

## Правила для инструментов

Базовые инструменты (валидаторы, рендереры) ДОЛЖНЫ:

1. **Игнорировать неизвестные поля** — не выдавать ошибку при встрече неизвестного поля.
2. **Сохранять неизвестные поля** — при операциях "parse → emit" (чтение и запись) неизвестные поля ДОЛЖНЫ быть сохранены.

## Рекомендуемый namespace `x:`

Для пользовательских и рендер-специфичных полей РЕКОМЕНДУЕТСЯ использовать namespace `x:`:

```yaml
# В корне плана
version: 1
meta:
  id: "my-project"
  title: "Мой проект"
x:
  team_assignments:
    - team: "Backend"
      lead: "Alice"
  risk_register:
    - risk_id: "R1"
      description: "Зависимость от внешнего API"

nodes:
  task1:
    title: "Задача 1"
    x:
      team: "SRE"
      risk: "high"
      custom_field: "любое значение"
```

```yaml
# В представлениях
version: 1
project: "my-project"
x:
  theme: "dark"
  export_format: "png"

gantt_views:
  main:
    title: "Основной план"
    x:
      zoom_level: "week"
    lanes:
      dev:
        title: "Разработка"
        nodes: [task1, task2]
        x:
          color: "#3498db"
```

### Зачем использовать `x:`

1. **Избежание конфликтов** — новые версии спецификации не будут конфликтовать с вашими расширениями.
2. **Явная маркировка** — понятно, что это расширение, а не часть core-спецификации.
3. **Группировка** — все пользовательские поля собраны в одном месте.

### Когда `x:` не обязателен

Использование `x:` РЕКОМЕНДУЕТСЯ, но не обязательно. Следующие форматы также допустимы:

```yaml
# Допустимо (но не рекомендуется)
nodes:
  task1:
    title: "Задача"
    team: "SRE"          # расширение без namespace
    risk: "high"         # расширение без namespace

# Рекомендуется
nodes:
  task1:
    title: "Задача"
    x:
      team: "SRE"
      risk: "high"
```

## Расширения рендереров

Рендереры МОГУТ поддерживать специфичные расширения. Такие расширения ДОЛЖНЫ:

1. Быть документированы в профиле рендерера (см. "Renderer profile: Mermaid Gantt").
2. Использовать namespace `x:` или явный namespace рендерера (например, `x.mermaid:`).
3. Не влиять на core-семантику формата.

**Пример расширения для планирования:**

```yaml
nodes:
  child_task:
    title: "Дочерняя задача"
    parent: parent_task
    x:
      scheduling:
        anchor_to_parent_start: true  # Опциональное наследование даты от родителя
```

## JSON Schema и расширяемость

JSON Schema для opskarta использует `additionalProperties: true` на всех уровнях, где разрешены расширения. Это означает:

- Схема НЕ выдаст ошибку для неизвестных полей.
- Расширения валидируются только по типам (если указаны в схеме расширения).

Если вам нужна валидация пользовательских расширений, создайте собственную JSON Schema, расширяющую базовую.

---

# Renderer profile: Mermaid Gantt

Этот раздел описывает поведение reference-рендерера Mermaid Gantt, включая умолчания и расширения, специфичные для этого рендерера.

> **Важно:** правила в этом разделе являются **non-core** и не обязательны для других инструментов. Они документированы для обеспечения предсказуемости reference-реализации.

## Умолчания рендерера

### Длительность по умолчанию

Если узел не имеет поля `duration`, рендерер использует значение **1 день** (`1d`). Это соответствует core-спецификации, которая определяет `1d` как значение по умолчанию для планируемых узлов.

```yaml
nodes:
  milestone:
    title: "Milestone"
    start: "2024-03-01"
    # duration не указан → используется 1d
    # На диаграмме: полоса 2024-03-01 — 2024-03-01
```

### Непланируемые узлы

Узлы без вычислимой даты начала (unscheduled) **пропускаются** рендерером без ошибки. Рендерер МОЖЕТ выдавать информационное предупреждение.

```yaml
nodes:
  idea:
    title: "Идея для обсуждения"
    # Нет start, нет after → узел не появится на диаграмме
```

## Расширение: наследование даты от родителя

Рендерер поддерживает опциональное расширение `x.scheduling.anchor_to_parent_start` для наследования даты начала от родительского узла.

### Активация

```yaml
nodes:
  parent_task:
    title: "Родительская задача"
    start: "2024-03-01"
    duration: "10d"

  child_task:
    title: "Дочерняя задача"
    parent: parent_task
    duration: "3d"
    x:
      scheduling:
        anchor_to_parent_start: true
    # effective_start = 2024-03-01 (наследуется от parent_task)
```

### Семантика

Когда `x.scheduling.anchor_to_parent_start: true`:

1. **Если у узла нет `start` и нет `after`:**
   - `effective_start(child) = effective_start(parent)`

2. **Если у узла есть `after` (но нет `start`):**
   - `effective_start = max(start_from_after, effective_start(parent))`

3. **Если у узла есть явный `start`:**
   - Используется явный `start` (расширение не влияет)

### Важно

- Это расширение является **non-core** и специфично для рендерера.
- Другие инструменты НЕ обязаны поддерживать это расширение.
- При отсутствии расширения узлы без `start`/`after` остаются непланируемыми (core-поведение).

## Отображение статусов

Рендерер отображает статусы узлов с помощью эмодзи и цветов.

### Маппинг статусов на эмодзи

| Статус | Эмодзи | Тег Mermaid |
|--------|--------|-------------|
| `done` | ✅ | `done` |
| `in_progress` | 🔄 | `active` |
| `blocked` | ⛔ | `crit` |
| `not_started` | (нет) | (нет тега) |

### Цвета по умолчанию

Если в `statuses` не указан `color`, используются значения по умолчанию:

| Статус | Цвет по умолчанию |
|--------|-------------------|
| `not_started` | `#9ca3af` (серый) |
| `in_progress` | `#0ea5e9` (синий) |
| `done` | `#22c55e` (зелёный) |
| `blocked` | `#fecaca` (светло-красный) |

Цвета из `statuses[].color` переопределяют значения по умолчанию.

## Исключения календаря в представлениях

### `excludes: ["weekends"]`

Влияет на расчёт дат согласно core-спецификации: суббота и воскресенье пропускаются при подсчёте рабочих дней.

### Конкретные даты

Конкретные даты в `excludes` (например, `"2024-03-08"`) являются **подсказками для рендерера**:

- Они передаются в Mermaid для визуального отображения (маркировка праздников).
- Они **НЕ влияют** на алгоритм расчёта дат в рендерере.

```yaml
gantt_views:
  main:
    excludes:
      - weekends        # Влияет на расчёт дат
      - "2024-03-08"    # Только визуальная метка в диаграмме
```

## Формат вывода

Рендерер генерирует код Mermaid Gantt:

```mermaid
gantt
    title Мой проект
    dateFormat YYYY-MM-DD
    excludes weekends

    section Разработка
    ✅ Задача 1        :done, task1, 2024-03-01, 5d
    🔄 Задача 2        :active, task2, after task1, 3d
```

### Особенности формата

- Эмодзи добавляются перед названием задачи.
- Зависимости (`after`) отображаются как `after <task_id>`.
- Секции (`section`) соответствуют дорожкам (`lanes`).

## Ограничения

1. **Единица `w` (недели):** рендерер преобразует недели в дни (`1w` → `5d` рабочих дней).
2. **Вложенные секции:** Mermaid не поддерживает вложенные секции; иерархия `parent` отображается плоско.

## Множественные зависимости (`after`)

Mermaid Gantt полностью поддерживает множественные зависимости в синтаксисе `after`:

```mermaid
task3    :task3, after task1 task2, 3d
```

Рендерер opskarta корректно транслирует `after: [task1, task2]` в формат Mermaid `after task1 task2`.

## Вехи (milestones)

Mermaid Gantt поддерживает вехи (milestones) — события-точки без длительности.

### Core-поле `milestone`

Если узел имеет `milestone: true`, рендерер отображает его как веху:

```yaml
nodes:
  release:
    title: "Релиз v1.0"
    milestone: true
    start: "2024-03-15"
    # Отображается как точка на временной шкале
```

### Маппинг на Mermaid

Узел с `milestone: true` генерирует Mermaid-тег `milestone`:

```mermaid
Релиз v1.0    :milestone, release, 2024-03-15, 1d
```

### Поведение

- Если `milestone: true` и `duration` не указан, используется `1d` для вычислений.
- На диаграмме веха отображается как точка/ромб, а не как полоса.
- Вехи могут иметь зависимости (`after`) и статусы (`status`).

## Поля представления для Mermaid

Рендерер поддерживает дополнительные поля в `gantt_views` для настройки вывода Mermaid.

### Маппинг полей

| Поле opskarta | Директива Mermaid | Описание |
|---------------|-------------------|----------|
| `date_format` | `dateFormat` | Формат входных дат (по умолчанию `YYYY-MM-DD`) |
| `axis_format` | `axisFormat` | Формат отображения дат на оси X |
| `tick_interval` | `tickInterval` | Интервал меток на оси X (опционально) |

### Пример

```yaml
gantt_views:
  overview:
    title: "Обзор проекта"
    date_format: "YYYY-MM-DD"
    axis_format: "%d %b"
    tick_interval: "1week"
    excludes: ["weekends"]
    lanes:
      main:
        title: "Основные задачи"
        nodes: [task1, task2]
```

Генерирует:

```mermaid
gantt
    title Обзор проекта
    dateFormat YYYY-MM-DD
    axisFormat %d %b
    tickInterval 1week
    excludes weekends

    section Основные задачи
    ...
```

### Формат `axis_format`

Поддерживаются стандартные директивы форматирования дат:

| Директива | Описание | Пример |
|-----------|----------|--------|
| `%Y` | Год (4 цифры) | `2024` |
| `%m` | Месяц (01-12) | `03` |
| `%d` | День (01-31) | `15` |
| `%b` | Сокращённый месяц | `Mar` |
| `%B` | Полный месяц | `March` |
| `%a` | Сокращённый день недели | `Fri` |

## Расширенные excludes в Mermaid

Mermaid Gantt поддерживает больше типов исключений, чем core-спецификация opskarta:

| Тип | Пример | Core opskarta | Mermaid |
|-----|--------|---------------|---------|
| Выходные | `"weekends"` | ✅ Поддерживается | ✅ Поддерживается |
| Конкретные даты | `"2024-03-08"` | ⚠️ Подсказка (не влияет на расчёт) | ✅ Поддерживается |
| Дни недели | `"sunday"` | ❌ Не поддерживается | ✅ Поддерживается |

Рендерер передаёт все значения `excludes` в Mermaid, но core-алгоритм расчёта дат учитывает только `"weekends"`.
